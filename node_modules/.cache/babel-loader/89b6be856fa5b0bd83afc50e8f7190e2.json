{"ast":null,"code":"import { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nclass IonRouteInner extends React.PureComponent {\n  render() {\n    return React.createElement(Route, {\n      path: this.props.path,\n      exact: this.props.exact,\n      render: this.props.render,\n      computedMatch: this.props.computedMatch\n    });\n  }\n\n}\n\nclass ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.getViewItemForTransition = this.getViewItemForTransition.bind(this);\n  }\n\n  createViewItem(outletId, reactElement, routeInfo, page) {\n    const viewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false\n    };\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props\n    };\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId); // Sync latest routes with viewItems\n\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      const viewItem = viewItems.find(v => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n    const children = viewItems.map(viewItem => {\n      let clonedChild;\n\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo, outletId) {\n    const {\n      viewItem,\n      match\n    } = this.findViewItemByPath(routeInfo.pathname, outletId);\n\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo, outletId) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, true);\n    return viewItem;\n  }\n\n  getViewItemForTransition(pathname) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(pathname, undefined, true, true);\n    return viewItem;\n  }\n\n  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n    let viewItem;\n    let match;\n    let viewStack;\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return {\n      viewItem,\n      match\n    };\n\n    function matchView(v) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component\n      };\n      const myMatch = matchPath(pathname, matchProps);\n\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n\n      return false;\n    }\n\n    function matchDefaultRoute(v) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {}\n        };\n        viewItem = v;\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n}\n\nfunction matchComponent(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath(pathname, matchProps);\n  return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  let html;\n\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n\n    return newEl.firstChild;\n  }\n\n  return undefined;\n}\n\nclass StackManager extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.stackContextValue = {\n      registerIonPage: this.registerIonPage.bind(this),\n      isInOutlet: () => true\n    };\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement); // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo) {\n    var _a, _b; // If routerOutlet isn't quite ready, give it another try in a moment\n\n\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      setTimeout(() => this.handlePageTransition(routeInfo), 10);\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      const leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n        const shouldLeavingViewBeRemoved = routeInfo.routeDirection !== 'none' && leavingViewItem && enteringViewItem !== leavingViewItem;\n\n        if (shouldLeavingViewBeRemoved) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      if (leavingViewItem && ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount)) {\n        leavingViewItem.mount = false;\n      }\n\n      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      }\n\n      if (!enteringViewItem) {\n        if (enteringRoute) {\n          enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n          this.context.addViewItem(enteringViewItem);\n        }\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        setTimeout(() => {\n          if (leavingViewItem.ionPageElement) {\n            leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n            leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n          }\n        }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page, routeInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: _shouldContinue => true\n    };\n  }\n\n  async transitionPage(routeInfo, enteringViewItem, leavingViewItem) {\n    const routerOutlet = this.routerOutletElement;\n    const direction = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n        const match = matchComponent$1(leavingViewItem.reactElement, routeInfo.pathname, true);\n\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl, leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction,\n        showGoBack: direction === 'forward',\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation\n      });\n    }\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    const ionRouterOutlet = React.Children.only(children);\n    this.ionRouterOutlet = ionRouterOutlet;\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n    return React.createElement(StackContext.Provider, {\n      value: this.stackContextValue\n    }, React.cloneElement(ionRouterOutlet, {\n      ref: node => {\n        if (ionRouterOutlet.props.setRef) {\n          ionRouterOutlet.props.setRef(node);\n        }\n\n        if (ionRouterOutlet.props.forwardedRef) {\n          ionRouterOutlet.props.forwardedRef.current = node;\n        }\n\n        this.routerOutletElement = node;\n        const {\n          ref\n        } = ionRouterOutlet;\n\n        if (typeof ref === 'function') {\n          ref(node);\n        }\n      }\n    }, components));\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n\n}\n\nfunction matchRoute(node, routeInfo) {\n  let matchedNode;\n  React.Children.forEach(node, child => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    const match = matchPath$1(routeInfo.pathname, matchProps);\n\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  } // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n\n\n  React.Children.forEach(node, child => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\n\nfunction matchComponent$1(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath$1(pathname, matchProps);\n  return match;\n}\n\nclass IonRouterInner extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.exitViewFromOtherOutletHandlers = [];\n    this.locationHistory = new LocationHistory();\n    this.viewStack = new ReactRouterViewStack();\n    this.routeMangerContextState = {\n      canGoBack: () => this.locationHistory.canGoBack(),\n      clearOutlet: this.viewStack.clear,\n      getViewItemForTransition: this.viewStack.getViewItemForTransition,\n      getChildrenToRender: this.viewStack.getChildrenToRender,\n      goBack: () => this.handleNavigateBack(),\n      createViewItem: this.viewStack.createViewItem,\n      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: this.viewStack.add,\n      unMountViewItem: this.viewStack.remove\n    };\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search\n    };\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n    this.state = {\n      routeInfo\n    };\n  }\n\n  handleChangeTab(tab, path, routeOptions) {\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n\n    if (routeInfo) {\n      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n        routeAction: 'push',\n        routeDirection: 'none'\n      });\n\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location, action) {\n    var _a, _b, _c;\n\n    let leavingLocationInfo;\n\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else if (action === 'REPLACE') {\n      leavingLocationInfo = this.locationHistory.previous();\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab\n          };\n        }\n\n        if (action === 'POP') {\n          const ri = this.locationHistory.current();\n\n          if (ri && ri.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(ri);\n            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n              routeAction: 'pop',\n              routeDirection: 'back'\n            });\n          } else {\n            const direction = 'none';\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: direction,\n              tab: this.currentTab\n            };\n          }\n        }\n\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n            tab: this.currentTab\n          };\n        }\n      }\n\n      let routeInfo;\n\n      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname\n        });\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = Object.assign(Object.assign({\n          id: generateId('routeInfo')\n        }, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params\n        });\n\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n          routeInfo.pushedByRoute = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute) || routeInfo.pushedByRoute;\n          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n    this.incomingRouteParams = {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab\n    };\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref = '/', routeAnimation) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n    const routeInfo = this.locationHistory.current();\n\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n\n      if (prevInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation\n        });\n\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute) {\n          this.props.history.goBack();\n        } else {\n          this.props.history.replace(prevInfo.pathname + (prevInfo.search || ''));\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab, originalHref, originalRouteOptions) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n\n    if (routeInfo) {\n      const newRouteInfo = Object.assign({}, routeInfo);\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n        routeAction: 'pop',\n        routeDirection: 'back'\n      });\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab) {\n    this.currentTab = tab;\n    const ri = Object.assign({}, this.locationHistory.current());\n\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return React.createElement(RouteManagerContext.Provider, {\n      value: this.routeMangerContextState\n    }, React.createElement(NavManager, {\n      ionRoute: IonRouteInner,\n      ionRedirect: {},\n      stackManager: StackManager,\n      routeInfo: this.state.routeInfo,\n      onNavigateBack: this.handleNavigateBack,\n      onNavigate: this.handleNavigate,\n      onSetCurrentTab: this.handleSetCurrentTab,\n      onChangeTab: this.handleChangeTab,\n      onResetTab: this.handleResetTab,\n      locationHistory: this.locationHistory\n    }, this.props.children));\n  }\n\n}\n\nconst IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nclass IonReactRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createBrowserHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location, action) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactMemoryRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location, action) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactHashRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createHashHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location, action) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"sources":["../src/ReactRouter/IonRouteInner.tsx","../src/ReactRouter/ReactRouterViewStack.tsx","../src/ReactRouter/clonePageElement.ts","../src/ReactRouter/StackManager.tsx","../src/ReactRouter/IonRouter.tsx","../src/ReactRouter/IonReactRouter.tsx","../src/ReactRouter/IonReactMemoryRouter.tsx","../src/ReactRouter/IonReactHashRouter.tsx"],"names":["matchComponent","matchPath","createHistory","Router"],"mappings":"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","sourcesContent":["import { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route path={this.props.path} exact={this.props.exact} render={this.props.render} computedMatch={(this.props as any).computedMatch} />\n    );\n  }\n}\n","import { IonRoute, RouteInfo, ViewItem, ViewLifeCycleManager, ViewStacks, generateId } from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router';\n\nexport class ReactRouterViewStack extends ViewStacks {\n\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.getViewItemForTransition = this.getViewItemForTransition.bind(this);\n  }\n\n  createViewItem(outletId: string, reactElement: React.ReactElement, routeInfo: RouteInfo, page?: HTMLElement) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false\n    };\n\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component\n    };\n\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find(v => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map(viewItem => {\n\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager key={`view-${viewItem.id}`} mount={viewItem.mount} removeView={() => this.remove(viewItem)}>\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager key={`view-${viewItem.id}`} mount={viewItem.mount} removeView={() => this.remove(viewItem)}>\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname!, outletId, false, true);\n    return viewItem;\n  }\n\n  getViewItemForTransition(pathname: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, undefined, true, true);\n    return viewItem;\n  }\n\n  private findViewItemByPath(pathname: string, outletId?: string, forceExact?: boolean, mustBeIonRoute?: boolean) {\n\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component\n      };\n      const myMatch = matchPath(pathname, matchProps);\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {}\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n\n  }\n\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import {\n  RouteInfo,\n  RouteManagerContext,\n  StackContext,\n  StackContextState,\n  ViewItem,\n  generateId,\n  getConfig\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router-dom';\n\nimport { clonePageElement } from './clonePageElement';\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\ninterface StackManagerState { }\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true\n  };\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n\n    // If routerOutlet isn't quite ready, give it another try in a moment\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      setTimeout(() => this.handlePageTransition(routeInfo), 10);\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      const leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n        const shouldLeavingViewBeRemoved = routeInfo.routeDirection !== 'none' && leavingViewItem && (enteringViewItem !== leavingViewItem);\n        if (shouldLeavingViewBeRemoved) {\n          leavingViewItem!.mount = false;\n        }\n      }\n\n      if (leavingViewItem && routeInfo.routeOptions?.unmount) {\n        leavingViewItem.mount = false;\n      }\n\n      const enteringRoute = matchRoute(this.ionRouterOutlet?.props.children, routeInfo) as React.ReactElement;\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      }\n      if (!enteringViewItem) {\n        if (enteringRoute) {\n          enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n          this.context.addViewItem(enteringViewItem);\n        }\n      }\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        setTimeout(() => {\n          if (leavingViewItem.ionPageElement) {\n            leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n            leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n          }\n        }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: _shouldContinue => true\n    };\n  }\n\n  async transitionPage(routeInfo: RouteInfo, enteringViewItem: ViewItem, leavingViewItem?: ViewItem) {\n\n    const routerOutlet = this.routerOutletElement!;\n\n    const direction = (routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root')\n      ? undefined\n      : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && (enteringViewItem === leavingViewItem)) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl: HTMLElement, leavingEl?: HTMLElement) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction as any,\n        showGoBack: direction === 'forward',\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation\n      });\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(\n      this.id,\n      this.ionRouterOutlet,\n      this.props.routeInfo,\n      () => {\n        this.forceUpdate();\n      });\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(ionRouterOutlet as any, {\n          ref: (node: HTMLIonRouterOutletElement) => {\n            if (ionRouterOutlet.props.setRef) {\n              ionRouterOutlet.props.setRef(node);\n            }\n            if (ionRouterOutlet.props.forwardedRef) {\n              ionRouterOutlet.props.forwardedRef.current = node;\n            }\n            this.routerOutletElement = node;\n            const { ref } = ionRouterOutlet as any;\n            if (typeof ref === 'function') {\n              ref(node);\n            }\n          }\n        },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","import { AnimationBuilder } from '@ionic/core';\nimport {\n  LocationHistory,\n  NavManager,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContext,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n  generateId,\n  getConfig\n} from '@ionic/react';\nimport { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport { RouteComponentProps, withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string, unmount?: boolean; };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (cb: (location: HistoryLocation<any>, action: HistoryAction) => void) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    getViewItemForTransition: this.viewStack.getViewItemForTransition,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo\n    };\n  }\n\n  handleChangeTab(tab: string, path: string, routeOptions?: any) {\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else if (action === 'REPLACE') {\n      leavingLocationInfo = this.locationHistory.previous();\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab\n          };\n        }\n        if (action === 'POP') {\n          const ri = this.locationHistory.current();\n          if (ri && ri.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(ri);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            const direction = 'none';\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: direction,\n              tab: this.currentTab\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...this.incomingRouteParams as RouteInfo,\n          lastPathname: leavingLocationInfo.pathname\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed = (this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward');\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.pushedByRoute = currentRouteInfo?.pushedByRoute || routeInfo.pushedByRoute;\n          routeInfo.routeDirection = currentRouteInfo?.routeDirection || routeInfo.routeDirection;\n          routeInfo.routeAnimation = currentRouteInfo?.routeAnimation || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  handleNavigate(path: string, routeAction: RouteAction, routeDirection?: RouterDirection, routeAnimation?: AnimationBuilder, routeOptions?: any, tab?: string) {\n    this.incomingRouteParams = {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab\n    };\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back', routeAnimation: routeAnimation || routeInfo.routeAnimation };\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute) {\n          this.props.history.goBack();\n        } else {\n          this.props.history.replace(prevInfo.pathname + (prevInfo.search || ''));\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider\n        value={this.routeMangerContextState}\n      >\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import { Action as HistoryAction, History, Location as HistoryLocation, createBrowserHistory as createHistory } from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps<THistoryLocationState = History.PoorMansUnknown> extends BrowserRouterProps {\n  history?: History<THistoryLocationState>;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n\n  historyListenHandler?: ((location: HistoryLocation, action: HistoryAction) => void);\n  history: History<History.PoorMansUnknown>;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport { MemoryRouterProps, Router } from 'react-router';\n\nimport { IonRouter, LocationState } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory<LocationState>;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory<LocationState>;\n  historyListenHandler?: ((location: HistoryLocation, action: HistoryAction) => void);\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import { Action as HistoryAction, History, Location as HistoryLocation, createHashHistory as createHistory } from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps<THistoryLocationState = History.PoorMansUnknown> extends BrowserRouterProps {\n  history?: History<THistoryLocationState>;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History<History.PoorMansUnknown>;\n  historyListenHandler?: ((location: HistoryLocation, action: HistoryAction) => void);\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    if (this.historyListenHandler) {\n      this.historyListenHandler(location, action);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}