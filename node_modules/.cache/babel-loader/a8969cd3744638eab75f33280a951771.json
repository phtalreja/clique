{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { p as pointerCoord } from './helpers-5c745fbd.js';\nvar cloneMap = new WeakMap();\n\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\n  if (inputRelativeY === void 0) {\n    inputRelativeY = 0;\n  }\n\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  } else {\n    removeClone(componentEl, inputEl);\n  }\n};\n\nvar isFocused = function (input) {\n  return input === input.getRootNode().activeElement;\n};\n\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  var parentEl = inputEl.parentNode; // DOM WRITES\n\n  var clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  var doc = componentEl.ownerDocument;\n  var tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\n};\n\nvar removeClone = function (componentEl, inputEl) {\n  var clone = cloneMap.get(componentEl);\n\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\n  if (!scrollEl || !inputEl) {\n    return function () {\n      return;\n    };\n  }\n\n  var scrollHideCaret = function (shouldHideCaret) {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n\n  var onBlur = function () {\n    return relocateInput(componentEl, inputEl, false);\n  };\n\n  var hideCaret = function () {\n    return scrollHideCaret(true);\n  };\n\n  var showCaret = function () {\n    return scrollHideCaret(false);\n  };\n\n  scrollEl.addEventListener('ionScrollStart', hideCaret);\n  scrollEl.addEventListener('ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return function () {\n    scrollEl.removeEventListener('ionScrollStart', hideCaret);\n    scrollEl.removeEventListener('ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\n\nvar enableInputBlurring = function () {\n  var focused = true;\n  var didScroll = false;\n  var doc = document;\n\n  var onScroll = function () {\n    didScroll = true;\n  };\n\n  var onFocusin = function () {\n    focused = true;\n  };\n\n  var onTouchend = function (ev) {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n\n    var active = doc.activeElement;\n\n    if (!active) {\n      return;\n    } // only blur if the active element is a text-input or a textarea\n\n\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    } // if the selected target is the active element, do not blur\n\n\n    var tapped = ev.target;\n\n    if (tapped === active) {\n      return;\n    }\n\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n\n    focused = false; // TODO: find a better way, why 50ms?\n\n    setTimeout(function () {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n\n  doc.addEventListener('ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return function () {\n    doc.removeEventListener('ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nvar SCROLL_ASSIST_SPEED = 0.3;\n\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\n  var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\n\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\n  // compute input's Y values relative to the body\n  var inputTop = inputRect.top;\n  var inputBottom = inputRect.bottom; // compute visible area\n\n  var visibleAreaTop = contentRect.top;\n  var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight); // compute safe area\n\n  var safeAreaTop = visibleAreaTop + 15;\n  var safeAreaBottom = visibleAreaBottom - 15; // figure out if each edge of the input is within the safe area\n\n  var distanceToBottom = safeAreaBottom - inputBottom;\n  var distanceToTop = safeAreaTop - inputTop; // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n\n  var desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0); // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n\n  var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  var distance = Math.abs(scrollAmount);\n  var duration = distance / SCROLL_ASSIST_SPEED;\n  var scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount: scrollAmount,\n    scrollDuration: scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, footerEl, keyboardHeight) {\n  var coord;\n\n  var touchStart = function (ev) {\n    coord = pointerCoord(ev);\n  };\n\n  var touchEnd = function (ev) {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    } // get where the touchend/mouseup ended\n\n\n    var endCoord = pointerCoord(ev); // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.preventDefault();\n      ev.stopPropagation(); // begin the input focus process\n\n      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n    }\n  };\n\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return function () {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\n\nvar jsSetFocus = function (componentEl, inputEl, contentEl, footerEl, keyboardHeight) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var scrollData, scrollContentTimeout_1, scrollContent_1, doubleKeyboardEventListener_1, scrollEl, totalScrollAmount;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!contentEl && !footerEl) {\n            return [2\n            /*return*/\n            ];\n          }\n\n          scrollData = getScrollData(componentEl, contentEl || footerEl, keyboardHeight);\n\n          if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n            // the text input is in a safe position that doesn't\n            // require it to be scrolled into view, just set focus now\n            inputEl.focus();\n            return [2\n            /*return*/\n            ];\n          } // temporarily move the focus to the focus holder so the browser\n          // doesn't freak out while it's trying to get the input in place\n          // at this point the native text input still does not have focus\n\n\n          relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n          inputEl.focus();\n          if (!(typeof window !== 'undefined')) return [3\n          /*break*/\n          , 3];\n\n          scrollContent_1 = function () {\n            return __awaiter(void 0, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    // clean up listeners and timeouts\n                    if (scrollContentTimeout_1 !== undefined) {\n                      clearTimeout(scrollContentTimeout_1);\n                    }\n\n                    window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n                    window.removeEventListener('ionKeyboardDidShow', scrollContent_1);\n                    if (!contentEl) return [3\n                    /*break*/\n                    , 2];\n                    return [4\n                    /*yield*/\n                    , contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration)];\n\n                  case 1:\n                    _a.sent();\n\n                    _a.label = 2;\n\n                  case 2:\n                    // the scroll view is in the correct position now\n                    // give the native text input focus\n                    relocateInput(componentEl, inputEl, false, scrollData.inputSafeY); // ensure this is the focused input\n\n                    inputEl.focus();\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          };\n\n          doubleKeyboardEventListener_1 = function () {\n            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n            window.addEventListener('ionKeyboardDidShow', scrollContent_1);\n          };\n\n          if (!contentEl) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , contentEl.getScrollElement()];\n\n        case 1:\n          scrollEl = _a.sent();\n          totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n\n          if (scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {\n            /**\n             * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n             * after the initial keyboard is shown. This prevents the webview from resizing\n             * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n             */\n            if (inputEl.type === 'password') {\n              // Add 50px to account for the \"Passwords\" bar\n              scrollData.scrollAmount += 50;\n              window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n            } else {\n              window.addEventListener('ionKeyboardDidShow', scrollContent_1);\n            }\n            /**\n             * This should only fire in 2 instances:\n             * 1. The app is very slow.\n             * 2. The app is running in a browser on an old OS\n             * that does not support Ionic Keyboard Events\n             */\n\n\n            scrollContentTimeout_1 = setTimeout(scrollContent_1, 1000);\n            return [2\n            /*return*/\n            ];\n          }\n\n          _a.label = 2;\n\n        case 2:\n          scrollContent_1();\n          _a.label = 3;\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\n  if (startCoord && endCoord) {\n    var deltaX = startCoord.x - endCoord.x;\n    var deltaY = startCoord.y - endCoord.y;\n    var distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > threshold * threshold;\n  }\n\n  return false;\n};\n\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\n\nvar enableScrollPadding = function (keyboardHeight) {\n  var doc = document;\n\n  var onFocusin = function (ev) {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n\n  var onFocusout = function (ev) {\n    setScrollPadding(ev.target, 0);\n  };\n\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return function () {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\n\nvar setScrollPadding = function (input, keyboardHeight) {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.parentElement && input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n\n  var el = input.closest('ion-content');\n\n  if (el === null) {\n    return;\n  }\n\n  var timer = el[PADDING_TIMER_KEY];\n\n  if (timer) {\n    clearTimeout(timer);\n  }\n\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\n  } else {\n    el[PADDING_TIMER_KEY] = setTimeout(function () {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nvar INPUT_BLURRING = true;\nvar SCROLL_PADDING = true;\n\nvar startInputShims = function (config) {\n  var doc = document;\n  var keyboardHeight = config.getNumber('keyboardHeight', 290);\n  var scrollAssist = config.getBoolean('scrollAssist', true);\n  var hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  var inputBlurring = config.getBoolean('inputBlurring', true);\n  var scrollPadding = config.getBoolean('scrollPadding', true);\n  var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  var hideCaretMap = new WeakMap();\n  var scrollAssistMap = new WeakMap();\n\n  var registerInput = function (componentEl) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var inputRoot, inputEl, scrollEl, footerEl, rmFn, rmFn;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!componentEl.componentOnReady) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , componentEl.componentOnReady()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            inputRoot = componentEl.shadowRoot || componentEl;\n            inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n            scrollEl = componentEl.closest('ion-content');\n            footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;\n\n            if (!inputEl) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n              rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n              hideCaretMap.set(componentEl, rmFn);\n            }\n\n            if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n              rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n              scrollAssistMap.set(componentEl, rmFn);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  var unregisterInput = function (componentEl) {\n    if (hideCaret) {\n      var fn = hideCaretMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      hideCaretMap.delete(componentEl);\n    }\n\n    if (scrollAssist) {\n      var fn = scrollAssistMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  } // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    registerInput(input);\n  }\n\n  doc.addEventListener('ionInputDidLoad', function (ev) {\n    registerInput(ev.detail);\n  });\n  doc.addEventListener('ionInputDidUnload', function (ev) {\n    unregisterInput(ev.detail);\n  });\n};\n\nexport { startInputShims };","map":{"version":3,"sources":["/Users/priyatalreja/Desktop/spectra-hacks/friendmatch/node_modules/@ionic/core/dist/esm-es5/input-shims-b956f530.js"],"names":["__awaiter","__generator","p","pointerCoord","cloneMap","WeakMap","relocateInput","componentEl","inputEl","shouldRelocate","inputRelativeY","has","addClone","removeClone","isFocused","input","getRootNode","activeElement","parentEl","parentNode","clonedEl","cloneNode","classList","add","tabIndex","appendChild","set","doc","ownerDocument","tx","dir","style","pointerEvents","transform","clone","get","delete","remove","enableHideCaretOnScroll","scrollEl","scrollHideCaret","shouldHideCaret","onBlur","hideCaret","showCaret","addEventListener","removeEventListener","SKIP_SELECTOR","enableInputBlurring","focused","didScroll","document","onScroll","onFocusin","onTouchend","ev","active","matches","tapped","target","closest","setTimeout","blur","SCROLL_ASSIST_SPEED","getScrollData","contentEl","keyboardHeight","itemEl","calcScrollData","getBoundingClientRect","defaultView","innerHeight","inputRect","contentRect","platformHeight","inputTop","top","inputBottom","bottom","visibleAreaTop","visibleAreaBottom","Math","min","safeAreaTop","safeAreaBottom","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","distance","abs","duration","scrollDuration","max","scrollPadding","inputSafeY","enableScrollAssist","footerEl","coord","touchStart","touchEnd","endCoord","hasPointerMoved","preventDefault","stopPropagation","jsSetFocus","scrollData","scrollContentTimeout_1","scrollContent_1","doubleKeyboardEventListener_1","totalScrollAmount","_a","label","focus","window","undefined","clearTimeout","scrollByPoint","sent","getScrollElement","scrollHeight","clientHeight","scrollTop","type","threshold","startCoord","deltaX","x","deltaY","y","PADDING_TIMER_KEY","enableScrollPadding","setScrollPadding","onFocusout","tagName","parentElement","el","timer","setProperty","INPUT_BLURRING","SCROLL_PADDING","startInputShims","config","getNumber","scrollAssist","getBoolean","inputBlurring","inputs","Array","from","querySelectorAll","hideCaretMap","scrollAssistMap","registerInput","inputRoot","rmFn","componentOnReady","shadowRoot","querySelector","unregisterInput","fn","_i","inputs_1","length","detail"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,WAApB,QAAuC,OAAvC;AACA,SAASC,CAAC,IAAIC,YAAd,QAAkC,uBAAlC;AACA,IAAIC,QAAQ,GAAG,IAAIC,OAAJ,EAAf;;AACA,IAAIC,aAAa,GAAG,UAAUC,WAAV,EAAuBC,OAAvB,EAAgCC,cAAhC,EAAgDC,cAAhD,EAAgE;AAChF,MAAIA,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAAEA,IAAAA,cAAc,GAAG,CAAjB;AAAqB;;AACtD,MAAIN,QAAQ,CAACO,GAAT,CAAaJ,WAAb,MAA8BE,cAAlC,EAAkD;AAC9C;AACH;;AACD,MAAIA,cAAJ,EAAoB;AAChBG,IAAAA,QAAQ,CAACL,WAAD,EAAcC,OAAd,EAAuBE,cAAvB,CAAR;AACH,GAFD,MAGK;AACDG,IAAAA,WAAW,CAACN,WAAD,EAAcC,OAAd,CAAX;AACH;AACJ,CAXD;;AAYA,IAAIM,SAAS,GAAG,UAAUC,KAAV,EAAiB;AAC7B,SAAOA,KAAK,KAAKA,KAAK,CAACC,WAAN,GAAoBC,aAArC;AACH,CAFD;;AAGA,IAAIL,QAAQ,GAAG,UAAUL,WAAV,EAAuBC,OAAvB,EAAgCE,cAAhC,EAAgD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIQ,QAAQ,GAAGV,OAAO,CAACW,UAAvB,CAV2D,CAW3D;;AACA,MAAIC,QAAQ,GAAGZ,OAAO,CAACa,SAAR,CAAkB,KAAlB,CAAf;AACAD,EAAAA,QAAQ,CAACE,SAAT,CAAmBC,GAAnB,CAAuB,cAAvB;AACAH,EAAAA,QAAQ,CAACI,QAAT,GAAoB,CAAC,CAArB;AACAN,EAAAA,QAAQ,CAACO,WAAT,CAAqBL,QAArB;AACAhB,EAAAA,QAAQ,CAACsB,GAAT,CAAanB,WAAb,EAA0Ba,QAA1B;AACA,MAAIO,GAAG,GAAGpB,WAAW,CAACqB,aAAtB;AACA,MAAIC,EAAE,GAAGF,GAAG,CAACG,GAAJ,KAAY,KAAZ,GAAoB,IAApB,GAA2B,CAAC,IAArC;AACAvB,EAAAA,WAAW,CAACwB,KAAZ,CAAkBC,aAAlB,GAAkC,MAAlC;AACAxB,EAAAA,OAAO,CAACuB,KAAR,CAAcE,SAAd,GAA0B,iBAAiBJ,EAAjB,GAAsB,KAAtB,GAA8BnB,cAA9B,GAA+C,gBAAzE;AACH,CArBD;;AAsBA,IAAIG,WAAW,GAAG,UAAUN,WAAV,EAAuBC,OAAvB,EAAgC;AAC9C,MAAI0B,KAAK,GAAG9B,QAAQ,CAAC+B,GAAT,CAAa5B,WAAb,CAAZ;;AACA,MAAI2B,KAAJ,EAAW;AACP9B,IAAAA,QAAQ,CAACgC,MAAT,CAAgB7B,WAAhB;AACA2B,IAAAA,KAAK,CAACG,MAAN;AACH;;AACD9B,EAAAA,WAAW,CAACwB,KAAZ,CAAkBC,aAAlB,GAAkC,EAAlC;AACAxB,EAAAA,OAAO,CAACuB,KAAR,CAAcE,SAAd,GAA0B,EAA1B;AACH,CARD;;AASA,IAAIK,uBAAuB,GAAG,UAAU/B,WAAV,EAAuBC,OAAvB,EAAgC+B,QAAhC,EAA0C;AACpE,MAAI,CAACA,QAAD,IAAa,CAAC/B,OAAlB,EAA2B;AACvB,WAAO,YAAY;AAAE;AAAS,KAA9B;AACH;;AACD,MAAIgC,eAAe,GAAG,UAAUC,eAAV,EAA2B;AAC7C,QAAI3B,SAAS,CAACN,OAAD,CAAb,EAAwB;AACpBF,MAAAA,aAAa,CAACC,WAAD,EAAcC,OAAd,EAAuBiC,eAAvB,CAAb;AACH;AACJ,GAJD;;AAKA,MAAIC,MAAM,GAAG,YAAY;AAAE,WAAOpC,aAAa,CAACC,WAAD,EAAcC,OAAd,EAAuB,KAAvB,CAApB;AAAoD,GAA/E;;AACA,MAAImC,SAAS,GAAG,YAAY;AAAE,WAAOH,eAAe,CAAC,IAAD,CAAtB;AAA+B,GAA7D;;AACA,MAAII,SAAS,GAAG,YAAY;AAAE,WAAOJ,eAAe,CAAC,KAAD,CAAtB;AAAgC,GAA9D;;AACAD,EAAAA,QAAQ,CAACM,gBAAT,CAA0B,gBAA1B,EAA4CF,SAA5C;AACAJ,EAAAA,QAAQ,CAACM,gBAAT,CAA0B,cAA1B,EAA0CD,SAA1C;AACApC,EAAAA,OAAO,CAACqC,gBAAR,CAAyB,MAAzB,EAAiCH,MAAjC;AACA,SAAO,YAAY;AACfH,IAAAA,QAAQ,CAACO,mBAAT,CAA6B,gBAA7B,EAA+CH,SAA/C;AACAJ,IAAAA,QAAQ,CAACO,mBAAT,CAA6B,cAA7B,EAA6CF,SAA7C;AACApC,IAAAA,OAAO,CAACqC,gBAAR,CAAyB,SAAzB,EAAoCH,MAApC;AACH,GAJD;AAKH,CApBD;;AAqBA,IAAIK,aAAa,GAAG,4BAApB;;AACA,IAAIC,mBAAmB,GAAG,YAAY;AAClC,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIC,SAAS,GAAG,KAAhB;AACA,MAAIvB,GAAG,GAAGwB,QAAV;;AACA,MAAIC,QAAQ,GAAG,YAAY;AACvBF,IAAAA,SAAS,GAAG,IAAZ;AACH,GAFD;;AAGA,MAAIG,SAAS,GAAG,YAAY;AACxBJ,IAAAA,OAAO,GAAG,IAAV;AACH,GAFD;;AAGA,MAAIK,UAAU,GAAG,UAAUC,EAAV,EAAc;AAC3B;AACA,QAAIL,SAAJ,EAAe;AACXA,MAAAA,SAAS,GAAG,KAAZ;AACA;AACH;;AACD,QAAIM,MAAM,GAAG7B,GAAG,CAACV,aAAjB;;AACA,QAAI,CAACuC,MAAL,EAAa;AACT;AACH,KAT0B,CAU3B;;;AACA,QAAIA,MAAM,CAACC,OAAP,CAAeV,aAAf,CAAJ,EAAmC;AAC/B;AACH,KAb0B,CAc3B;;;AACA,QAAIW,MAAM,GAAGH,EAAE,CAACI,MAAhB;;AACA,QAAID,MAAM,KAAKF,MAAf,EAAuB;AACnB;AACH;;AACD,QAAIE,MAAM,CAACD,OAAP,CAAeV,aAAf,KAAiCW,MAAM,CAACE,OAAP,CAAeb,aAAf,CAArC,EAAoE;AAChE;AACH;;AACDE,IAAAA,OAAO,GAAG,KAAV,CAtB2B,CAuB3B;;AACAY,IAAAA,UAAU,CAAC,YAAY;AACnB,UAAI,CAACZ,OAAL,EAAc;AACVO,QAAAA,MAAM,CAACM,IAAP;AACH;AACJ,KAJS,EAIP,EAJO,CAAV;AAKH,GA7BD;;AA8BAnC,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,gBAArB,EAAuCO,QAAvC;AACAzB,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,SAArB,EAAgCQ,SAAhC,EAA2C,IAA3C;AACA1B,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,UAArB,EAAiCS,UAAjC,EAA6C,KAA7C;AACA,SAAO,YAAY;AACf3B,IAAAA,GAAG,CAACmB,mBAAJ,CAAwB,gBAAxB,EAA0CM,QAA1C,EAAoD,IAApD;AACAzB,IAAAA,GAAG,CAACmB,mBAAJ,CAAwB,SAAxB,EAAmCO,SAAnC,EAA8C,IAA9C;AACA1B,IAAAA,GAAG,CAACmB,mBAAJ,CAAwB,UAAxB,EAAoCQ,UAApC,EAAgD,KAAhD;AACH,GAJD;AAKH,CAhDD;;AAiDA,IAAIS,mBAAmB,GAAG,GAA1B;;AACA,IAAIC,aAAa,GAAG,UAAUzD,WAAV,EAAuB0D,SAAvB,EAAkCC,cAAlC,EAAkD;AAClE,MAAIC,MAAM,GAAG5D,WAAW,CAACqD,OAAZ,CAAoB,qBAApB,KAA8CrD,WAA3D;AACA,SAAO6D,cAAc,CAACD,MAAM,CAACE,qBAAP,EAAD,EAAiCJ,SAAS,CAACI,qBAAV,EAAjC,EAAoEH,cAApE,EAAoF3D,WAAW,CAACqB,aAAZ,CAA0B0C,WAA1B,CAAsCC,WAA1H,CAArB;AACH,CAHD;;AAIA,IAAIH,cAAc,GAAG,UAAUI,SAAV,EAAqBC,WAArB,EAAkCP,cAAlC,EAAkDQ,cAAlD,EAAkE;AACnF;AACA,MAAIC,QAAQ,GAAGH,SAAS,CAACI,GAAzB;AACA,MAAIC,WAAW,GAAGL,SAAS,CAACM,MAA5B,CAHmF,CAInF;;AACA,MAAIC,cAAc,GAAGN,WAAW,CAACG,GAAjC;AACA,MAAII,iBAAiB,GAAGC,IAAI,CAACC,GAAL,CAAST,WAAW,CAACK,MAArB,EAA6BJ,cAAc,GAAGR,cAA9C,CAAxB,CANmF,CAOnF;;AACA,MAAIiB,WAAW,GAAGJ,cAAc,GAAG,EAAnC;AACA,MAAIK,cAAc,GAAGJ,iBAAiB,GAAG,EAAzC,CATmF,CAUnF;;AACA,MAAIK,gBAAgB,GAAGD,cAAc,GAAGP,WAAxC;AACA,MAAIS,aAAa,GAAGH,WAAW,GAAGR,QAAlC,CAZmF,CAanF;;AACA,MAAIY,mBAAmB,GAAGN,IAAI,CAACO,KAAL,CAAYH,gBAAgB,GAAG,CAApB,GAC/B,CAACA,gBAD8B,GAE9BC,aAAa,GAAG,CAAjB,GACI,CAACA,aADL,GAEI,CAJgB,CAA1B,CAdmF,CAmBnF;AACA;;AACA,MAAIG,YAAY,GAAGR,IAAI,CAACC,GAAL,CAASK,mBAAT,EAA8BZ,QAAQ,GAAGI,cAAzC,CAAnB;AACA,MAAIW,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAASF,YAAT,CAAf;AACA,MAAIG,QAAQ,GAAGF,QAAQ,GAAG3B,mBAA1B;AACA,MAAI8B,cAAc,GAAGZ,IAAI,CAACC,GAAL,CAAS,GAAT,EAAcD,IAAI,CAACa,GAAL,CAAS,GAAT,EAAcF,QAAd,CAAd,CAArB;AACA,SAAO;AACHH,IAAAA,YAAY,EAAEA,YADX;AAEHI,IAAAA,cAAc,EAAEA,cAFb;AAGHE,IAAAA,aAAa,EAAE7B,cAHZ;AAIH8B,IAAAA,UAAU,EAAE,EAAErB,QAAQ,GAAGQ,WAAb,IAA4B;AAJrC,GAAP;AAMH,CA/BD;;AAgCA,IAAIc,kBAAkB,GAAG,UAAU1F,WAAV,EAAuBC,OAAvB,EAAgCyD,SAAhC,EAA2CiC,QAA3C,EAAqDhC,cAArD,EAAqE;AAC1F,MAAIiC,KAAJ;;AACA,MAAIC,UAAU,GAAG,UAAU7C,EAAV,EAAc;AAC3B4C,IAAAA,KAAK,GAAGhG,YAAY,CAACoD,EAAD,CAApB;AACH,GAFD;;AAGA,MAAI8C,QAAQ,GAAG,UAAU9C,EAAV,EAAc;AACzB;AACA,QAAI,CAAC4C,KAAL,EAAY;AACR;AACH,KAJwB,CAKzB;;;AACA,QAAIG,QAAQ,GAAGnG,YAAY,CAACoD,EAAD,CAA3B,CANyB,CAOzB;AACA;;AACA,QAAI,CAACgD,eAAe,CAAC,CAAD,EAAIJ,KAAJ,EAAWG,QAAX,CAAhB,IAAwC,CAACxF,SAAS,CAACN,OAAD,CAAtD,EAAiE;AAC7D+C,MAAAA,EAAE,CAACiD,cAAH;AACAjD,MAAAA,EAAE,CAACkD,eAAH,GAF6D,CAG7D;;AACAC,MAAAA,UAAU,CAACnG,WAAD,EAAcC,OAAd,EAAuByD,SAAvB,EAAkCiC,QAAlC,EAA4ChC,cAA5C,CAAV;AACH;AACJ,GAfD;;AAgBA3D,EAAAA,WAAW,CAACsC,gBAAZ,CAA6B,YAA7B,EAA2CuD,UAA3C,EAAuD,IAAvD;AACA7F,EAAAA,WAAW,CAACsC,gBAAZ,CAA6B,UAA7B,EAAyCwD,QAAzC,EAAmD,IAAnD;AACA,SAAO,YAAY;AACf9F,IAAAA,WAAW,CAACuC,mBAAZ,CAAgC,YAAhC,EAA8CsD,UAA9C,EAA0D,IAA1D;AACA7F,IAAAA,WAAW,CAACuC,mBAAZ,CAAgC,UAAhC,EAA4CuD,QAA5C,EAAsD,IAAtD;AACH,GAHD;AAIH,CA3BD;;AA4BA,IAAIK,UAAU,GAAG,UAAUnG,WAAV,EAAuBC,OAAvB,EAAgCyD,SAAhC,EAA2CiC,QAA3C,EAAqDhC,cAArD,EAAqE;AAAE,SAAOlE,SAAS,CAAC,KAAK,CAAN,EAAS,KAAK,CAAd,EAAiB,KAAK,CAAtB,EAAyB,YAAY;AACzI,QAAI2G,UAAJ,EAAgBC,sBAAhB,EAAwCC,eAAxC,EAAyDC,6BAAzD,EAAwFvE,QAAxF,EAAkGwE,iBAAlG;AACA,WAAO9G,WAAW,CAAC,IAAD,EAAO,UAAU+G,EAAV,EAAc;AACnC,cAAQA,EAAE,CAACC,KAAX;AACI,aAAK,CAAL;AACI,cAAI,CAAChD,SAAD,IAAc,CAACiC,QAAnB,EAA6B;AACzB,mBAAO,CAAC;AAAE;AAAH,aAAP;AACH;;AACDS,UAAAA,UAAU,GAAG3C,aAAa,CAACzD,WAAD,EAAe0D,SAAS,IAAIiC,QAA5B,EAAuChC,cAAvC,CAA1B;;AACA,cAAID,SAAS,IAAIgB,IAAI,CAACU,GAAL,CAASgB,UAAU,CAAClB,YAApB,IAAoC,CAArD,EAAwD;AACpD;AACA;AACAjF,YAAAA,OAAO,CAAC0G,KAAR;AACA,mBAAO,CAAC;AAAE;AAAH,aAAP;AACH,WAVL,CAWI;AACA;AACA;;;AACA5G,UAAAA,aAAa,CAACC,WAAD,EAAcC,OAAd,EAAuB,IAAvB,EAA6BmG,UAAU,CAACX,UAAxC,CAAb;AACAxF,UAAAA,OAAO,CAAC0G,KAAR;AACA,cAAI,EAAE,OAAOC,MAAP,KAAkB,WAApB,CAAJ,EAAsC,OAAO,CAAC;AAAE;AAAH,YAAc,CAAd,CAAP;;AACtCN,UAAAA,eAAe,GAAG,YAAY;AAAE,mBAAO7G,SAAS,CAAC,KAAK,CAAN,EAAS,KAAK,CAAd,EAAiB,KAAK,CAAtB,EAAyB,YAAY;AACjF,qBAAOC,WAAW,CAAC,IAAD,EAAO,UAAU+G,EAAV,EAAc;AACnC,wBAAQA,EAAE,CAACC,KAAX;AACI,uBAAK,CAAL;AACI;AACA,wBAAIL,sBAAsB,KAAKQ,SAA/B,EAA0C;AACtCC,sBAAAA,YAAY,CAACT,sBAAD,CAAZ;AACH;;AACDO,oBAAAA,MAAM,CAACrE,mBAAP,CAA2B,oBAA3B,EAAiDgE,6BAAjD;AACAK,oBAAAA,MAAM,CAACrE,mBAAP,CAA2B,oBAA3B,EAAiD+D,eAAjD;AACA,wBAAI,CAAC5C,SAAL,EAAgB,OAAO,CAAC;AAAE;AAAH,sBAAc,CAAd,CAAP;AAChB,2BAAO,CAAC;AAAE;AAAH,sBAAcA,SAAS,CAACqD,aAAV,CAAwB,CAAxB,EAA2BX,UAAU,CAAClB,YAAtC,EAAoDkB,UAAU,CAACd,cAA/D,CAAd,CAAP;;AACJ,uBAAK,CAAL;AACImB,oBAAAA,EAAE,CAACO,IAAH;;AACAP,oBAAAA,EAAE,CAACC,KAAH,GAAW,CAAX;;AACJ,uBAAK,CAAL;AACI;AACA;AACA3G,oBAAAA,aAAa,CAACC,WAAD,EAAcC,OAAd,EAAuB,KAAvB,EAA8BmG,UAAU,CAACX,UAAzC,CAAb,CAHJ,CAII;;AACAxF,oBAAAA,OAAO,CAAC0G,KAAR;AACA,2BAAO,CAAC;AAAE;AAAH,qBAAP;AAnBR;AAqBH,eAtBiB,CAAlB;AAuBH,aAxB+C,CAAhB;AAwB3B,WAxBL;;AAyBAJ,UAAAA,6BAA6B,GAAG,YAAY;AACxCK,YAAAA,MAAM,CAACrE,mBAAP,CAA2B,oBAA3B,EAAiDgE,6BAAjD;AACAK,YAAAA,MAAM,CAACtE,gBAAP,CAAwB,oBAAxB,EAA8CgE,eAA9C;AACH,WAHD;;AAIA,cAAI,CAAC5C,SAAL,EAAgB,OAAO,CAAC;AAAE;AAAH,YAAc,CAAd,CAAP;AAChB,iBAAO,CAAC;AAAE;AAAH,YAAcA,SAAS,CAACuD,gBAAV,EAAd,CAAP;;AACJ,aAAK,CAAL;AACIjF,UAAAA,QAAQ,GAAGyE,EAAE,CAACO,IAAH,EAAX;AACAR,UAAAA,iBAAiB,GAAGxE,QAAQ,CAACkF,YAAT,GAAwBlF,QAAQ,CAACmF,YAArD;;AACA,cAAIf,UAAU,CAAClB,YAAX,GAA2BsB,iBAAiB,GAAGxE,QAAQ,CAACoF,SAA5D,EAAwE;AACpE;;;;;AAKA,gBAAInH,OAAO,CAACoH,IAAR,KAAiB,UAArB,EAAiC;AAC7B;AACAjB,cAAAA,UAAU,CAAClB,YAAX,IAA2B,EAA3B;AACA0B,cAAAA,MAAM,CAACtE,gBAAP,CAAwB,oBAAxB,EAA8CiE,6BAA9C;AACH,aAJD,MAKK;AACDK,cAAAA,MAAM,CAACtE,gBAAP,CAAwB,oBAAxB,EAA8CgE,eAA9C;AACH;AACD;;;;;;;;AAMAD,YAAAA,sBAAsB,GAAG/C,UAAU,CAACgD,eAAD,EAAkB,IAAlB,CAAnC;AACA,mBAAO,CAAC;AAAE;AAAH,aAAP;AACH;;AACDG,UAAAA,EAAE,CAACC,KAAH,GAAW,CAAX;;AACJ,aAAK,CAAL;AACIJ,UAAAA,eAAe;AACfG,UAAAA,EAAE,CAACC,KAAH,GAAW,CAAX;;AACJ,aAAK,CAAL;AAAQ,iBAAO,CAAC;AAAE;AAAH,WAAP;AA/EZ;AAiFH,KAlFiB,CAAlB;AAmFH,GArFuG,CAAhB;AAqFnF,CArFL;;AAsFA,IAAIV,eAAe,GAAG,UAAUsB,SAAV,EAAqBC,UAArB,EAAiCxB,QAAjC,EAA2C;AAC7D,MAAIwB,UAAU,IAAIxB,QAAlB,EAA4B;AACxB,QAAIyB,MAAM,GAAID,UAAU,CAACE,CAAX,GAAe1B,QAAQ,CAAC0B,CAAtC;AACA,QAAIC,MAAM,GAAIH,UAAU,CAACI,CAAX,GAAe5B,QAAQ,CAAC4B,CAAtC;AACA,QAAIxC,QAAQ,GAAGqC,MAAM,GAAGA,MAAT,GAAkBE,MAAM,GAAGA,MAA1C;AACA,WAAOvC,QAAQ,GAAImC,SAAS,GAAGA,SAA/B;AACH;;AACD,SAAO,KAAP;AACH,CARD;;AASA,IAAIM,iBAAiB,GAAG,kBAAxB;;AACA,IAAIC,mBAAmB,GAAG,UAAUlE,cAAV,EAA0B;AAChD,MAAIvC,GAAG,GAAGwB,QAAV;;AACA,MAAIE,SAAS,GAAG,UAAUE,EAAV,EAAc;AAC1B8E,IAAAA,gBAAgB,CAAC9E,EAAE,CAACI,MAAJ,EAAYO,cAAZ,CAAhB;AACH,GAFD;;AAGA,MAAIoE,UAAU,GAAG,UAAU/E,EAAV,EAAc;AAC3B8E,IAAAA,gBAAgB,CAAC9E,EAAE,CAACI,MAAJ,EAAY,CAAZ,CAAhB;AACH,GAFD;;AAGAhC,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,SAArB,EAAgCQ,SAAhC;AACA1B,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,UAArB,EAAiCyF,UAAjC;AACA,SAAO,YAAY;AACf3G,IAAAA,GAAG,CAACmB,mBAAJ,CAAwB,SAAxB,EAAmCO,SAAnC;AACA1B,IAAAA,GAAG,CAACmB,mBAAJ,CAAwB,UAAxB,EAAoCwF,UAApC;AACH,GAHD;AAIH,CAdD;;AAeA,IAAID,gBAAgB,GAAG,UAAUtH,KAAV,EAAiBmD,cAAjB,EAAiC;AACpD,MAAInD,KAAK,CAACwH,OAAN,KAAkB,OAAtB,EAA+B;AAC3B;AACH;;AACD,MAAIxH,KAAK,CAACyH,aAAN,IAAuBzH,KAAK,CAACyH,aAAN,CAAoBD,OAApB,KAAgC,WAA3D,EAAwE;AACpE;AACH;;AACD,MAAIxH,KAAK,CAACyH,aAAN,IACAzH,KAAK,CAACyH,aAAN,CAAoBA,aADpB,IAEAzH,KAAK,CAACyH,aAAN,CAAoBA,aAApB,CAAkCD,OAAlC,KAA8C,eAFlD,EAEmE;AAC/D;AACH;;AACD,MAAIE,EAAE,GAAG1H,KAAK,CAAC6C,OAAN,CAAc,aAAd,CAAT;;AACA,MAAI6E,EAAE,KAAK,IAAX,EAAiB;AACb;AACH;;AACD,MAAIC,KAAK,GAAGD,EAAE,CAACN,iBAAD,CAAd;;AACA,MAAIO,KAAJ,EAAW;AACPrB,IAAAA,YAAY,CAACqB,KAAD,CAAZ;AACH;;AACD,MAAIxE,cAAc,GAAG,CAArB,EAAwB;AACpBuE,IAAAA,EAAE,CAAC1G,KAAH,CAAS4G,WAAT,CAAqB,mBAArB,EAA0CzE,cAAc,GAAG,IAA3D;AACH,GAFD,MAGK;AACDuE,IAAAA,EAAE,CAACN,iBAAD,CAAF,GAAwBtE,UAAU,CAAC,YAAY;AAC3C4E,MAAAA,EAAE,CAAC1G,KAAH,CAAS4G,WAAT,CAAqB,mBAArB,EAA0C,KAA1C;AACH,KAFiC,EAE/B,GAF+B,CAAlC;AAGH;AACJ,CA5BD;;AA6BA,IAAIC,cAAc,GAAG,IAArB;AACA,IAAIC,cAAc,GAAG,IAArB;;AACA,IAAIC,eAAe,GAAG,UAAUC,MAAV,EAAkB;AACpC,MAAIpH,GAAG,GAAGwB,QAAV;AACA,MAAIe,cAAc,GAAG6E,MAAM,CAACC,SAAP,CAAiB,gBAAjB,EAAmC,GAAnC,CAArB;AACA,MAAIC,YAAY,GAAGF,MAAM,CAACG,UAAP,CAAkB,cAAlB,EAAkC,IAAlC,CAAnB;AACA,MAAIvG,SAAS,GAAGoG,MAAM,CAACG,UAAP,CAAkB,mBAAlB,EAAuC,IAAvC,CAAhB;AACA,MAAIC,aAAa,GAAGJ,MAAM,CAACG,UAAP,CAAkB,eAAlB,EAAmC,IAAnC,CAApB;AACA,MAAInD,aAAa,GAAGgD,MAAM,CAACG,UAAP,CAAkB,eAAlB,EAAmC,IAAnC,CAApB;AACA,MAAIE,MAAM,GAAGC,KAAK,CAACC,IAAN,CAAW3H,GAAG,CAAC4H,gBAAJ,CAAqB,yBAArB,CAAX,CAAb;AACA,MAAIC,YAAY,GAAG,IAAInJ,OAAJ,EAAnB;AACA,MAAIoJ,eAAe,GAAG,IAAIpJ,OAAJ,EAAtB;;AACA,MAAIqJ,aAAa,GAAG,UAAUnJ,WAAV,EAAuB;AAAE,WAAOP,SAAS,CAAC,KAAK,CAAN,EAAS,KAAK,CAAd,EAAiB,KAAK,CAAtB,EAAyB,YAAY;AAC9F,UAAI2J,SAAJ,EAAenJ,OAAf,EAAwB+B,QAAxB,EAAkC2D,QAAlC,EAA4C0D,IAA5C,EAAkDA,IAAlD;AACA,aAAO3J,WAAW,CAAC,IAAD,EAAO,UAAU+G,EAAV,EAAc;AACnC,gBAAQA,EAAE,CAACC,KAAX;AACI,eAAK,CAAL;AACI,gBAAI,CAAC1G,WAAW,CAACsJ,gBAAjB,EAAmC,OAAO,CAAC;AAAE;AAAH,cAAc,CAAd,CAAP;AACnC,mBAAO,CAAC;AAAE;AAAH,cAActJ,WAAW,CAACsJ,gBAAZ,EAAd,CAAP;;AACJ,eAAK,CAAL;AACI7C,YAAAA,EAAE,CAACO,IAAH;;AACAP,YAAAA,EAAE,CAACC,KAAH,GAAW,CAAX;;AACJ,eAAK,CAAL;AACI0C,YAAAA,SAAS,GAAGpJ,WAAW,CAACuJ,UAAZ,IAA0BvJ,WAAtC;AACAC,YAAAA,OAAO,GAAGmJ,SAAS,CAACI,aAAV,CAAwB,OAAxB,KAAoCJ,SAAS,CAACI,aAAV,CAAwB,UAAxB,CAA9C;AACAxH,YAAAA,QAAQ,GAAGhC,WAAW,CAACqD,OAAZ,CAAoB,aAApB,CAAX;AACAsC,YAAAA,QAAQ,GAAI,CAAC3D,QAAF,GAAchC,WAAW,CAACqD,OAAZ,CAAoB,YAApB,CAAd,GAAkD,IAA7D;;AACA,gBAAI,CAACpD,OAAL,EAAc;AACV,qBAAO,CAAC;AAAE;AAAH,eAAP;AACH;;AACD,gBAAI,CAAC,CAAC+B,QAAF,IAAcI,SAAd,IAA2B,CAAC6G,YAAY,CAAC7I,GAAb,CAAiBJ,WAAjB,CAAhC,EAA+D;AAC3DqJ,cAAAA,IAAI,GAAGtH,uBAAuB,CAAC/B,WAAD,EAAcC,OAAd,EAAuB+B,QAAvB,CAA9B;AACAiH,cAAAA,YAAY,CAAC9H,GAAb,CAAiBnB,WAAjB,EAA8BqJ,IAA9B;AACH;;AACD,gBAAI,CAAC,CAAC,CAACrH,QAAF,IAAc,CAAC,CAAC2D,QAAjB,KAA8B+C,YAA9B,IAA8C,CAACQ,eAAe,CAAC9I,GAAhB,CAAoBJ,WAApB,CAAnD,EAAqF;AACjFqJ,cAAAA,IAAI,GAAG3D,kBAAkB,CAAC1F,WAAD,EAAcC,OAAd,EAAuB+B,QAAvB,EAAiC2D,QAAjC,EAA2ChC,cAA3C,CAAzB;AACAuF,cAAAA,eAAe,CAAC/H,GAAhB,CAAoBnB,WAApB,EAAiCqJ,IAAjC;AACH;;AACD,mBAAO,CAAC;AAAE;AAAH,aAAP;AAvBR;AAyBH,OA1BiB,CAAlB;AA2BH,KA7B4D,CAAhB;AA6BxC,GA7BL;;AA8BA,MAAII,eAAe,GAAG,UAAUzJ,WAAV,EAAuB;AACzC,QAAIoC,SAAJ,EAAe;AACX,UAAIsH,EAAE,GAAGT,YAAY,CAACrH,GAAb,CAAiB5B,WAAjB,CAAT;;AACA,UAAI0J,EAAJ,EAAQ;AACJA,QAAAA,EAAE;AACL;;AACDT,MAAAA,YAAY,CAACpH,MAAb,CAAoB7B,WAApB;AACH;;AACD,QAAI0I,YAAJ,EAAkB;AACd,UAAIgB,EAAE,GAAGR,eAAe,CAACtH,GAAhB,CAAoB5B,WAApB,CAAT;;AACA,UAAI0J,EAAJ,EAAQ;AACJA,QAAAA,EAAE;AACL;;AACDR,MAAAA,eAAe,CAACrH,MAAhB,CAAuB7B,WAAvB;AACH;AACJ,GAfD;;AAgBA,MAAI4I,aAAa,IAAIP,cAArB,EAAqC;AACjC5F,IAAAA,mBAAmB;AACtB;;AACD,MAAI+C,aAAa,IAAI8C,cAArB,EAAqC;AACjCT,IAAAA,mBAAmB,CAAClE,cAAD,CAAnB;AACH,GA7DmC,CA8DpC;AACA;AACA;;;AACA,OAAK,IAAIgG,EAAE,GAAG,CAAT,EAAYC,QAAQ,GAAGf,MAA5B,EAAoCc,EAAE,GAAGC,QAAQ,CAACC,MAAlD,EAA0DF,EAAE,EAA5D,EAAgE;AAC5D,QAAInJ,KAAK,GAAGoJ,QAAQ,CAACD,EAAD,CAApB;AACAR,IAAAA,aAAa,CAAC3I,KAAD,CAAb;AACH;;AACDY,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,iBAArB,EAAyC,UAAUU,EAAV,EAAc;AACnDmG,IAAAA,aAAa,CAACnG,EAAE,CAAC8G,MAAJ,CAAb;AACH,GAFD;AAGA1I,EAAAA,GAAG,CAACkB,gBAAJ,CAAqB,mBAArB,EAA2C,UAAUU,EAAV,EAAc;AACrDyG,IAAAA,eAAe,CAACzG,EAAE,CAAC8G,MAAJ,CAAf;AACH,GAFD;AAGH,CA3ED;;AA4EA,SAASvB,eAAT","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { p as pointerCoord } from './helpers-5c745fbd.js';\nvar cloneMap = new WeakMap();\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\n    if (inputRelativeY === void 0) { inputRelativeY = 0; }\n    if (cloneMap.has(componentEl) === shouldRelocate) {\n        return;\n    }\n    if (shouldRelocate) {\n        addClone(componentEl, inputEl, inputRelativeY);\n    }\n    else {\n        removeClone(componentEl, inputEl);\n    }\n};\nvar isFocused = function (input) {\n    return input === input.getRootNode().activeElement;\n};\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\n    // this allows for the actual input to receive the focus from\n    // the user's touch event, but before it receives focus, it\n    // moves the actual input to a location that will not screw\n    // up the app's layout, and does not allow the native browser\n    // to attempt to scroll the input into place (messing up headers/footers)\n    // the cloned input fills the area of where native input should be\n    // while the native input fakes out the browser by relocating itself\n    // before it receives the actual focus event\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\n    var parentEl = inputEl.parentNode;\n    // DOM WRITES\n    var clonedEl = inputEl.cloneNode(false);\n    clonedEl.classList.add('cloned-input');\n    clonedEl.tabIndex = -1;\n    parentEl.appendChild(clonedEl);\n    cloneMap.set(componentEl, clonedEl);\n    var doc = componentEl.ownerDocument;\n    var tx = doc.dir === 'rtl' ? 9999 : -9999;\n    componentEl.style.pointerEvents = 'none';\n    inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\n};\nvar removeClone = function (componentEl, inputEl) {\n    var clone = cloneMap.get(componentEl);\n    if (clone) {\n        cloneMap.delete(componentEl);\n        clone.remove();\n    }\n    componentEl.style.pointerEvents = '';\n    inputEl.style.transform = '';\n};\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\n    if (!scrollEl || !inputEl) {\n        return function () { return; };\n    }\n    var scrollHideCaret = function (shouldHideCaret) {\n        if (isFocused(inputEl)) {\n            relocateInput(componentEl, inputEl, shouldHideCaret);\n        }\n    };\n    var onBlur = function () { return relocateInput(componentEl, inputEl, false); };\n    var hideCaret = function () { return scrollHideCaret(true); };\n    var showCaret = function () { return scrollHideCaret(false); };\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\n    inputEl.addEventListener('blur', onBlur);\n    return function () {\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\n        inputEl.addEventListener('ionBlur', onBlur);\n    };\n};\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\nvar enableInputBlurring = function () {\n    var focused = true;\n    var didScroll = false;\n    var doc = document;\n    var onScroll = function () {\n        didScroll = true;\n    };\n    var onFocusin = function () {\n        focused = true;\n    };\n    var onTouchend = function (ev) {\n        // if app did scroll return early\n        if (didScroll) {\n            didScroll = false;\n            return;\n        }\n        var active = doc.activeElement;\n        if (!active) {\n            return;\n        }\n        // only blur if the active element is a text-input or a textarea\n        if (active.matches(SKIP_SELECTOR)) {\n            return;\n        }\n        // if the selected target is the active element, do not blur\n        var tapped = ev.target;\n        if (tapped === active) {\n            return;\n        }\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n            return;\n        }\n        focused = false;\n        // TODO: find a better way, why 50ms?\n        setTimeout(function () {\n            if (!focused) {\n                active.blur();\n            }\n        }, 50);\n    };\n    doc.addEventListener('ionScrollStart', onScroll);\n    doc.addEventListener('focusin', onFocusin, true);\n    doc.addEventListener('touchend', onTouchend, false);\n    return function () {\n        doc.removeEventListener('ionScrollStart', onScroll, true);\n        doc.removeEventListener('focusin', onFocusin, true);\n        doc.removeEventListener('touchend', onTouchend, false);\n    };\n};\nvar SCROLL_ASSIST_SPEED = 0.3;\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\n    var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\n    // compute input's Y values relative to the body\n    var inputTop = inputRect.top;\n    var inputBottom = inputRect.bottom;\n    // compute visible area\n    var visibleAreaTop = contentRect.top;\n    var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n    // compute safe area\n    var safeAreaTop = visibleAreaTop + 15;\n    var safeAreaBottom = visibleAreaBottom - 15;\n    // figure out if each edge of the input is within the safe area\n    var distanceToBottom = safeAreaBottom - inputBottom;\n    var distanceToTop = safeAreaTop - inputTop;\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n    var desiredScrollAmount = Math.round((distanceToBottom < 0)\n        ? -distanceToBottom\n        : (distanceToTop > 0)\n            ? -distanceToTop\n            : 0);\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n    // gets focus, so make sure we don't scroll the input above the visible area\n    var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n    var distance = Math.abs(scrollAmount);\n    var duration = distance / SCROLL_ASSIST_SPEED;\n    var scrollDuration = Math.min(400, Math.max(150, duration));\n    return {\n        scrollAmount: scrollAmount,\n        scrollDuration: scrollDuration,\n        scrollPadding: keyboardHeight,\n        inputSafeY: -(inputTop - safeAreaTop) + 4\n    };\n};\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, footerEl, keyboardHeight) {\n    var coord;\n    var touchStart = function (ev) {\n        coord = pointerCoord(ev);\n    };\n    var touchEnd = function (ev) {\n        // input cover touchend/mouseup\n        if (!coord) {\n            return;\n        }\n        // get where the touchend/mouseup ended\n        var endCoord = pointerCoord(ev);\n        // focus this input if the pointer hasn't moved XX pixels\n        // and the input doesn't already have focus\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            // begin the input focus process\n            jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n        }\n    };\n    componentEl.addEventListener('touchstart', touchStart, true);\n    componentEl.addEventListener('touchend', touchEnd, true);\n    return function () {\n        componentEl.removeEventListener('touchstart', touchStart, true);\n        componentEl.removeEventListener('touchend', touchEnd, true);\n    };\n};\nvar jsSetFocus = function (componentEl, inputEl, contentEl, footerEl, keyboardHeight) { return __awaiter(void 0, void 0, void 0, function () {\n    var scrollData, scrollContentTimeout_1, scrollContent_1, doubleKeyboardEventListener_1, scrollEl, totalScrollAmount;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!contentEl && !footerEl) {\n                    return [2 /*return*/];\n                }\n                scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);\n                if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n                    // the text input is in a safe position that doesn't\n                    // require it to be scrolled into view, just set focus now\n                    inputEl.focus();\n                    return [2 /*return*/];\n                }\n                // temporarily move the focus to the focus holder so the browser\n                // doesn't freak out while it's trying to get the input in place\n                // at this point the native text input still does not have focus\n                relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n                inputEl.focus();\n                if (!(typeof window !== 'undefined')) return [3 /*break*/, 3];\n                scrollContent_1 = function () { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                // clean up listeners and timeouts\n                                if (scrollContentTimeout_1 !== undefined) {\n                                    clearTimeout(scrollContentTimeout_1);\n                                }\n                                window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n                                window.removeEventListener('ionKeyboardDidShow', scrollContent_1);\n                                if (!contentEl) return [3 /*break*/, 2];\n                                return [4 /*yield*/, contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration)];\n                            case 1:\n                                _a.sent();\n                                _a.label = 2;\n                            case 2:\n                                // the scroll view is in the correct position now\n                                // give the native text input focus\n                                relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n                                // ensure this is the focused input\n                                inputEl.focus();\n                                return [2 /*return*/];\n                        }\n                    });\n                }); };\n                doubleKeyboardEventListener_1 = function () {\n                    window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n                    window.addEventListener('ionKeyboardDidShow', scrollContent_1);\n                };\n                if (!contentEl) return [3 /*break*/, 2];\n                return [4 /*yield*/, contentEl.getScrollElement()];\n            case 1:\n                scrollEl = _a.sent();\n                totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n                if (scrollData.scrollAmount > (totalScrollAmount - scrollEl.scrollTop)) {\n                    /**\n                     * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n                     * after the initial keyboard is shown. This prevents the webview from resizing\n                     * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n                     */\n                    if (inputEl.type === 'password') {\n                        // Add 50px to account for the \"Passwords\" bar\n                        scrollData.scrollAmount += 50;\n                        window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener_1);\n                    }\n                    else {\n                        window.addEventListener('ionKeyboardDidShow', scrollContent_1);\n                    }\n                    /**\n                     * This should only fire in 2 instances:\n                     * 1. The app is very slow.\n                     * 2. The app is running in a browser on an old OS\n                     * that does not support Ionic Keyboard Events\n                     */\n                    scrollContentTimeout_1 = setTimeout(scrollContent_1, 1000);\n                    return [2 /*return*/];\n                }\n                _a.label = 2;\n            case 2:\n                scrollContent_1();\n                _a.label = 3;\n            case 3: return [2 /*return*/];\n        }\n    });\n}); };\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\n    if (startCoord && endCoord) {\n        var deltaX = (startCoord.x - endCoord.x);\n        var deltaY = (startCoord.y - endCoord.y);\n        var distance = deltaX * deltaX + deltaY * deltaY;\n        return distance > (threshold * threshold);\n    }\n    return false;\n};\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\nvar enableScrollPadding = function (keyboardHeight) {\n    var doc = document;\n    var onFocusin = function (ev) {\n        setScrollPadding(ev.target, keyboardHeight);\n    };\n    var onFocusout = function (ev) {\n        setScrollPadding(ev.target, 0);\n    };\n    doc.addEventListener('focusin', onFocusin);\n    doc.addEventListener('focusout', onFocusout);\n    return function () {\n        doc.removeEventListener('focusin', onFocusin);\n        doc.removeEventListener('focusout', onFocusout);\n    };\n};\nvar setScrollPadding = function (input, keyboardHeight) {\n    if (input.tagName !== 'INPUT') {\n        return;\n    }\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n        return;\n    }\n    if (input.parentElement &&\n        input.parentElement.parentElement &&\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n        return;\n    }\n    var el = input.closest('ion-content');\n    if (el === null) {\n        return;\n    }\n    var timer = el[PADDING_TIMER_KEY];\n    if (timer) {\n        clearTimeout(timer);\n    }\n    if (keyboardHeight > 0) {\n        el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\n    }\n    else {\n        el[PADDING_TIMER_KEY] = setTimeout(function () {\n            el.style.setProperty('--keyboard-offset', '0px');\n        }, 120);\n    }\n};\nvar INPUT_BLURRING = true;\nvar SCROLL_PADDING = true;\nvar startInputShims = function (config) {\n    var doc = document;\n    var keyboardHeight = config.getNumber('keyboardHeight', 290);\n    var scrollAssist = config.getBoolean('scrollAssist', true);\n    var hideCaret = config.getBoolean('hideCaretOnScroll', true);\n    var inputBlurring = config.getBoolean('inputBlurring', true);\n    var scrollPadding = config.getBoolean('scrollPadding', true);\n    var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n    var hideCaretMap = new WeakMap();\n    var scrollAssistMap = new WeakMap();\n    var registerInput = function (componentEl) { return __awaiter(void 0, void 0, void 0, function () {\n        var inputRoot, inputEl, scrollEl, footerEl, rmFn, rmFn;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!componentEl.componentOnReady) return [3 /*break*/, 2];\n                    return [4 /*yield*/, componentEl.componentOnReady()];\n                case 1:\n                    _a.sent();\n                    _a.label = 2;\n                case 2:\n                    inputRoot = componentEl.shadowRoot || componentEl;\n                    inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n                    scrollEl = componentEl.closest('ion-content');\n                    footerEl = (!scrollEl) ? componentEl.closest('ion-footer') : null;\n                    if (!inputEl) {\n                        return [2 /*return*/];\n                    }\n                    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n                        rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n                        hideCaretMap.set(componentEl, rmFn);\n                    }\n                    if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n                        rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n                        scrollAssistMap.set(componentEl, rmFn);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    }); };\n    var unregisterInput = function (componentEl) {\n        if (hideCaret) {\n            var fn = hideCaretMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            hideCaretMap.delete(componentEl);\n        }\n        if (scrollAssist) {\n            var fn = scrollAssistMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            scrollAssistMap.delete(componentEl);\n        }\n    };\n    if (inputBlurring && INPUT_BLURRING) {\n        enableInputBlurring();\n    }\n    if (scrollPadding && SCROLL_PADDING) {\n        enableScrollPadding(keyboardHeight);\n    }\n    // Input might be already loaded in the DOM before ion-device-hacks did.\n    // At this point we need to look for all of the inputs not registered yet\n    // and register them.\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input = inputs_1[_i];\n        registerInput(input);\n    }\n    doc.addEventListener('ionInputDidLoad', (function (ev) {\n        registerInput(ev.detail);\n    }));\n    doc.addEventListener('ionInputDidUnload', (function (ev) {\n        unregisterInput(ev.detail);\n    }));\n};\nexport { startInputShims };\n"]},"metadata":{},"sourceType":"module"}